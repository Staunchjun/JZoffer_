# B树
>查找树：二叉查找树（Binary Search Tree），平衡二叉查找树（Balanced Binary Search Tree），红黑树(Red-Black Tree )，B-tree/B+-tree/ B-tree (B~Tree)。前三者是典型的二叉查找树结构，其查找的时间复杂度**O(log2N)与树的深度相关**，那么降低树的深度自然会提高查找效率。


![8394323_130745821166S](media/15045751151858/8394323_130745821166Sc.jpg)

在上图可以看出B树内一个内结点x若含有n[x]个关键字，那么x将含有n[x]+1个子女。如含有2个关键字D H的内结点有3个子女，而含有3个关键字Q T X的内结点有4个子女。

## 特性

1. 树中每个结点**最多含有m个孩子**（m>=2）；
2. 除根结点和叶子结点外，其它每个结点**至少有[ceil(m / 2)]个孩子**（其中ceil(x)是一个取上限的函数）；
3. 若**根结点不是叶子结点，则至少有2个孩子**（特殊情况：没有孩子的根结点，即根结点为叶子结点，整棵树只有一个根节点）；
4. 所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部接点或查询失败的接点，实际上这些结点不存在，指向这些结点的指针都为null)；
    1. 每个非终端结点中包含有n个关键字信息： (n，P0，K1，P1，K2，P2，......，Kn，Pn)。其中：
      1.   Ki (i=1...n)为关键字，且关键字按顺序升序排序K(i-1)< Ki。 
     2.     Pi为指向子树根的接点，且指针P(i-1)指向子树种所有结点的关键字均小于Ki，但都大于K(i-1)。 
      3.  关键字的个数n必须满足： [ceil(m / 2)-1]<= n <= m-1。
      
### 插入
![0_1324206104Z6fI.gif](media/15045751151858/0_1324206104Z6fI.gif.jpeg)

### 删除
首先查找B树中需删除的元素,如果该元素在B树中存在，则将该元素在其结点中进行删除，如果删除该元素后，首先判断该元素是否有左右孩子结点，如果有，则上移孩子结点中的某相近元素(“左孩子最右边的节点”或“右孩子最左边的节点”)到父节点中，然后是移动之后的情况；如果没有，直接删除后，移动之后的情况。
删除元素，移动相应元素之后，如果某结点中元素数目（即关键字数）小于ceil(m/2)-1，则需要看其某相邻兄弟结点是否丰满（结点中元素个数大于ceil(m/2)-1）（还记得第一节中关于B树的第5个特性中的c点么?： c)除根结点之外的结点（包括叶子结点）的关键字的个数n必须满足： （ceil(m / 2)-1）<= n <= m-1。m表示最多含有m个孩子，n表示关键字数。在本小节中举的一颗B树的示例中，关键字数n满足：2<=n<=4），如果丰满，则向父节点借一个元素来满足条件；如果其相邻兄弟都刚脱贫，即借了之后其结点数目小于ceil(m/2)-1，则该结点与其相邻的某一兄弟结点进行“合并”成一个结点，以此来满足条件。那咱们通过下面实例来详细了解吧。
>以上述插入操作构造的一棵5阶B树（树中最多含有m（m=5）个孩子，因此关键字数最小为ceil(m / 2)-1=2。还是这句话，关键字数小了（小于2个）就合并，大了（超过4个）就分裂）

# B+树
>B+-tree：是应文件系统所需而产生的一种B-tree的变形树

### 一棵m阶的B+树和m阶的B树的异同点在于：
 1. 有n棵子树的结点中含有n-1 个关键字； 
 2. 所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且**叶子结点本身依关键字的大小自小而大的顺序链接。** (而B 树的叶子节点并没有包括全部需要查找的信息)
 3. **所有的非终端结点可以看成是索引部分**，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也包含需要查找的有效信息)

![8394323_1307440587b6WG](media/15045751151858/8394323_1307440587b6WG.jpg)


### B+-tree比B 树更适合实际应用中操作系统的文件索引和数据库索引
数据库索引采用B+树的主要原因是 B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）。


